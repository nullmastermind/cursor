- Write code as a senior developer, but make it understandable for a 10-year-old.
- Use "type" instead of "interface" in TypeScript.
- Avoid QueryBuilder in NestJS; use `dataSource` to get repositories.
- Use descriptive names for variables and functions.
- Prioritize readability over brevity.
- Use modern JavaScript/TypeScript features.
- Include error handling and input validation.
- Use environment variables for configuration.
- Provide unit tests for critical functions.
- Use async/await for asynchronous operations.
- Demonstrate proper use of TypeScript's type system.
- Show how to structure larger applications when relevant.
- Implement error logging and monitoring strategies.
- Use strict TypeScript configuration.
- Follow SOLID principles in object-oriented design.
- Implement security measures against common vulnerabilities.
- Use linting tools and consistent code style.
- Implement data validation and sanitization at all entry points.
- Use dependency injection where applicable.
- Implement caching strategies for performance.
- Use appropriate design patterns for common problems.
- Optimize database indexing and queries.
- Use CI/CD practices.
- Implement proper API and library versioning.
- Use appropriate data structures and algorithms for optimization.
- Implement error boundaries and fallback mechanisms.
- Use feature flags for safer deployment.
- Implement logging and tracing for debugging.
- For Rust, use Result and Option types, leverage ownership system, use traits, and implement concurrency patterns.
- For C#, use LINQ, async/await, properties, proper exception handling, attributes, consider garbage collection, use events and delegates, implement multithreading with TPL, use generics and extension methods.
- Keep related code together in larger, well-commented functions.
- Use descriptive comments within functions to explain steps.
- Use longer, more descriptive function names.
- Use whitespace and formatting to improve readability within larger functions.
- Group related operations using labeled code blocks or regions.
- Use local variables with descriptive names for complex operations.
- Implement error handling and validation within the main function body.
- Keep complex algorithms within a single function, using comments to explain each part.
- Perform simple operations inline with clear comments.
- Keep related async calls within the same function.
- Use switch statements or if-else chains within a function.
- Implement logging and debugging directly within the main function body.
- Consider multiple algorithm approaches based on problem constraints.
- Analyze time and space complexity for optimal performance.
- Use clear names and comments in algorithm implementations.
- Choose appropriate data structures for algorithm efficiency.
- Consider edge cases and include robust error handling in algorithms.
- Ensure proper termination conditions for recursive algorithms.
- Implement streaming or chunking for large datasets.
- Choose appropriate graph representations for graph algorithms.
- Use dynamic programming techniques when applicable.
- Choose sorting algorithms based on data characteristics.
- Use advanced search techniques like A* for pathfinding.
- Consider efficient data structures for string manipulation.
- Implement parallel versions of algorithms for large datasets.
- Use randomized algorithms when appropriate.
- Consider approximation algorithms for NP-hard problems.
- Implement online algorithms for streaming data.
- Use proper naming conventions for well-known algorithms.
- Implement custom comparators for complex sorting requirements.
- Consider sorting algorithm stability when order of equal elements matters.
- Implement efficient data compression algorithms when necessary.
- Use camelCase for variable and function names in JavaScript and TypeScript.